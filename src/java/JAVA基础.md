# JAVA基础

## String 

- `==`比较地址  `equals`比较内容

### 不可变的好处

- 可以缓存hash值：例如作`Map`的`key`。只需计算一次
- `String pool`的需要：如果一个String对象已经被创建过了，那么就会从`String pool`中获取引用，只有`String`是不可变的，才可能使用`String pool`
- 安全性：`String`经常作为参数，不可变性保证参数不可变
- 线程安全：不可变天生具备线程安全，可以在多个线程中安全使用

### `String,StringBuilder,StringBuilder`

- 后两个可变，`StringBuilder`线程不安全，`StringBuilder`线程安全，内部使用`sychronized`同步

### `String pool`

- 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。

  ```java
  String s1 = new String("aaa");
  String s2 = new String("aaa");
  System.out.println(s1 == s2);           // false
  String s3 = s1.intern();
  String s4 = s2.intern();
  System.out.println(s3 == s4);           // true
  String s5 = "bbb";
  String s6 = "bbb";
  System.out.println(s5 == s6);  // true
  ```



### `new String("abc")`

- 使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。
- "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；
- 而使用 new 的方式会在堆中创建一个字符串对象。



## 关键字

### `static`初始化顺序

- 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）



## `Object`通用方法

### `equals`实现

- 检查是否是同一对象的引用
- 检查是否是同一个类型
- 将`Object`对象转型
- 判断每个关键域是否相等



## 抽象类与接口

### 抽象类

- 抽象类与抽象方法都使用`abstract`关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类
- 抽象类与普通类最大的区别就是抽象类不能被实例化，只能被继承

### 接口

- java8之前可以把接口看成完全抽象的类，不能有任何方法的实现
- java8开始，接口也可以有默认的方法实现，因为不支持默认方法的接口维护成本太高了。java8之前如果一个接口添加了新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。

### **比较**

- 从设计层面上看，抽象类是一种`IS-A`关系，需要满足里氏替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种`LIKR-A`关系，它只是提供一种方法实现契约，并不要求接口和实现类具有`IS-A`关系
- 从实现上看，一个类可以实现多个接口，但是不能继承多个抽象类
- 接口的字段只能是`static`和`final`类型的，而抽象类的字段没有这种限制
- 接口的成员只能是`public`的，而抽象类的成员可以有多种访问权限

### 使用选择

- 接口
  - 需要让不相关的类都实现一个方法，例如不相关的类都可以实现`Comparable`接口
  - 需要使用多重继承
- 抽象类
  - 需要在几个相关的类中共享代码
  - 需要能控制继承来的成员的访问权限，而不是都为`public`
  - 需要继承非静态和非常量字段
- 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为应该类添加行为。并且从java8开始，接口可以有默认的方法实现，使得修改接口的成本也变得很低。

