# 字节算法题（牛客网）

## 2.LRU

- `hashmap` + `双向链表`

- 核心是两个数据结构同时更新

  ```java
  import java.util.*;
  
  
  public class Solution {
      /**
       * lru design
       * @param operators int整型二维数组 the ops
       * @param k int整型 the k
       * @return int整型一维数组
       */
      private LinkedHashMap<Integer,Integer> map;
      private int size;
      public int[] LRU (int[][] operators, int k) {
          // write code here
          map = new LinkedHashMap(k);
          size = k;
          List<Integer> temp = new ArrayList<>();
          for(int [] cmd : operators){
              //set
              if(cmd[0] == 1){
                  int key = cmd[1];
                  int val = cmd[2];
                  set(key,val);
              }
              //get
              else{
                  int key = cmd[1];
                  temp.add(get(key));
              }
          }
          int[] res = new int[temp.size()];
          for(int i = 0 ; i < temp.size() ; i++){
              res[i] = temp.get(i);
          }
          return res;
      }
      
      private int get(int key){
          if(map.keySet().contains(key)){
              int val = map.get(key);
              map.remove(key);
              map.put(key,val);
              return val;
          }
          return -1;
      }
      
      private void set(int key,int val){
          if(map.keySet().contains(key)){
              map.remove(key);
              map.put(key,val);
          }
          else{
              if(map.size() == size){
                  Iterator<Map.Entry<Integer,Integer>> ite = map.entrySet().iterator();
                  Map.Entry<Integer,Integer> entry = ite.next();
                  map.remove(entry.getKey());
              }
              map.put(key,val);
          }
      }
  }
  ```

  ```java
  import java.util.*;
  
  
  public class Solution {
      /**
       * lru design
       * @param operators int整型二维数组 the ops
       * @param k int整型 the k
       * @return int整型一维数组
       */
      private HashMap<Integer,Integer> map;
      private Deque<Integer> deque;
      private int cap;
      public int[] LRU (int[][] operators, int k) {
          // write code here
          map = new HashMap<>();
          deque = new LinkedList<>();
          cap = k;
          List<Integer> ans = new ArrayList<>();
          for(int[] cmd : operators){
              if(cmd[0] == 1){
                  int key = cmd[1];
                  int val = cmd[2];
                  set(key,val);
              }
              else{
                  int key = cmd[1];
                  int val = get(key);
                  ans.add(val);
              }
          }
          int[] res = new int[ans.size()];
          for(int i = 0 ; i < ans.size() ; i++){
              res[i] = ans.get(i);
          }
          return res;
      }
      
      private void set(int key,int val){
          //存在key 直接覆盖 更新双端队列
          if(map.containsKey(key)){
              map.put(key,val);
              deque.remove(key);
              deque.addFirst(key);
          }
          //不存在key
          else{
              // 满了
              if(map.size() == cap){
                  int k = deque.removeLast();
                  map.remove(k);
              }
              map.put(key,val);
              deque.addFirst(key);
          }
      }
      
      private int get(int key){
          //不存在key
          if(!map.containsKey(key)){
              return -1;
          }
          int val = map.get(key);
          deque.remove(key);
          deque.addFirst(key);
          return val;
      }
      
      
  }
  ```

  ```java
  import java.util.*;
  
  
  public class Solution {
      /**
       * lru design
       * @param operators int整型二维数组 the ops
       * @param k int整型 the k
       * @return int整型一维数组
       */
      class Node{
          int key;
          int val;
          Node pre;
          Node next;
          public Node(int key,int val){
              this.key = key;
              this.val = val;
          }
      }
      private HashMap<Integer,Node> map;
      private Node head = new Node(0,0);
      private Node tail = new Node(0,0);
      private int cap;
      public int[] LRU (int[][] operators, int k) {
          // write code here
          map = new HashMap<>();
          cap = k;
          head.next = tail;
          tail.pre = head;
          ArrayList<Integer> ans = new ArrayList<>();
          for(int[] cmd : operators){
              if(cmd[0] == 1){
                  int key = cmd[1];
                  int val = cmd[2];
                  set(key,val);
              }
              else{
                  int key = cmd[1];
                  ans.add(get(key));
              }
          }
          int[] res = new int[ans.size()];
          for(int i = 0 ; i < ans.size() ; i++){
              res[i] = ans.get(i);
          }
          return res;
      }
      
      private void set(int key,int val){
          if(map.containsKey(key)){
              Node n = map.get(key);
              n.val = val;
              deleteNode(n);
              addFirst(n);
          }
          else{
              if(map.size() == cap){
                  int k = tail.pre.key;
                  tail.pre.pre.next = tail;
                  tail.pre = tail.pre.pre;
                  map.remove(k);
              }
              Node n = new Node(key,val);
              map.put(key,n);
              addFirst(n);
          }
      }
      
      private int get(int key){
          if(map.containsKey(key)){
              Node n = map.get(key);
              int res = n.val;
              deleteNode(n);
              addFirst(n);
              return res;
          }
          else{
              return -1;
          }
      }
      
      
      private void deleteNode(Node n){
          n.pre.next = n.next;
          n.next.pre = n.pre;
      }
      
      private void addFirst(Node n){
          n.next = head.next;
          n.next.pre = n;
          head.next = n;
          n.pre = head;
          
      }
      
      
  }
  ```



## 3.判断链表是否有环

- 快慢指针

  ```java
  /**
   * Definition for singly-linked list.
   * class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode(int x) {
   *         val = x;
   *         next = null;
   *     }
   * }
   */
  public class Solution {
      public boolean hasCycle(ListNode head) {
          ListNode fast = head;
          ListNode slow = head;
          while(fast != null && fast.next != null){
              fast = fast.next.next;
              slow = slow.next;
              if(slow == fast)
                  return true;
          }
          return false;
      }
  }
  ```

  



## 4.二叉树遍历

- 前序 核心：先入栈右节点，再入栈左节点  根右左

  ```java
  public void preorder(TreeNode root, ArrayList<Integer> list) {
      Stack<TreeNode> stack = new Stack<>();
      stack.push(root);
      while (!stack.isEmpty()) {
          TreeNode curr = stack.pop();
          list.add(curr.val);
          if (curr.right != null) {
              stack.push(curr.right);
          }
          if (curr.left != null) {
              stack.push(curr.left);
          }
      }
  }
  ```

- 中序 核心：一直放左节点

  ```java
  public void inorder(TreeNode root, ArrayList<Integer> list) {
      Stack<TreeNode> stack = new Stack<>();
      TreeNode curr = root;
      //这个判断条件有学问的 后面这个curr != null 一定要的
      while (!stack.isEmpty() || curr != null) {
          while (curr != null) {
              stack.push(curr);
              curr = curr.left;
          }
          curr = stack.pop();
          list.add(curr.val);
          curr = curr.right;
      }
  }
  ```

- 后序 核心：从头开始插入  根左右

  ```java
  public void postorder(TreeNode root, ArrayList<Integer> list) {
      Stack<TreeNode> stack = new Stack<>();
      stack.push(root);
      while (!stack.isEmpty()) {
          TreeNode curr = stack.pop();
          //
          list.add(0, curr.val);
          if(curr.left != null) {
            stack.push(curr.left);
          }
          if(curr.right != null) {
             stack.push(curr.right);
          }
      }
  }
  ```

  

## 5.排序数组二分查找第一个大于给定值的位置

>请实现有重复数字的升序数组的二分查找。
>
>输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一。

- 先把不存在的结果的情况去掉

  ```java
  public int upper_bound_ (int n, int v, int[] a) {
          if(a[n - 1] < v)
              return n + 1;
          // write code here
          int left = 0;
          int right = n - 1;
          while(left < right){
              while(left < right && a[right] == a[right - 1])
                  right--;
              int mid = left + (right - left) / 2;
              if(a[mid] < v){
                  left = mid + 1;
              }
              else if(a[mid] >= v){
                  right = mid;
              }
          }
          return left + 1;
      }
  ```




## 6.寻找第K大

- 二分 + 快排

  ```java
  public class Solution {
      public int findKth(int[] a, int n, int K) {
          // write code here
          return findK(a,0,n-1,K);
      }
      
      private int findK(int[] arr,int left,int right,int k){
          if(left <= right){
              int pivot = partition(arr,left,right);
              if(pivot == k - 1){
                  return arr[pivot];
              }
              else if(pivot < k - 1){
                  return findK(arr,pivot + 1 , right, k );
              }
              else{
                  return findK(arr,left,pivot - 1, k );
              }
          }
          return -1;
      }
      
      private int partition(int[] arr,int left,int right){
          int pivot = arr[left];
          while(left < right){
              while(left < right && arr[right] <= pivot){
                  right--;
              }
              arr[left] = arr[right];
              while(left < right && arr[left] >= pivot){
                  left++;
              }
              arr[right] = arr[left];
          }
          arr[left] = pivot;
          return left;
      }
      
      
  }
  ```



## 7.最长无重复字符子串

- 滑动窗口

- set维护窗口，保证窗口内没有重复元素

  ```java
   public int maxLength (int[] arr) {
          // write code here
          Set<Integer> set = new HashSet<>();
          int res = 0;
          int left = 0;
          for(int i = 0 ; i < arr.length ; i++){
              while(set.contains(arr[i])){
                  set.remove(arr[left++]);
              }
              set.add(arr[i]);
              res = Math.max(res,i - left + 1);
          }
          return res;
      }
  ```



## 8.找到链表的环入口

- 快慢相遇，从头开始每次走一步

  ```java
    public ListNode detectCycle(ListNode head) {
          ListNode fast = head;
          ListNode slow = head;
          while(true){
              if(fast == null || fast.next == null)
                  return null;
              fast = fast.next.next;
              slow = slow.next;
              if(fast == slow)
                  break;
          }
          slow = head;
          while(slow != fast){
              slow = slow.next;
              fast = fast.next;
          }
          return slow;
      }
  ```

  



## 9.链表中的节点每k组翻转

- 先判断元素够不够k个

  ```java
  public ListNode reverseKGroup (ListNode head, int k) {
          // write code here
          ListNode[] nodes = reverse(head,k);
          ListNode res = nodes[0];
          ListNode h = nodes[0];
          ListNode t = nodes[1];
          ListNode n = nodes[2];
          while(n != null){
              nodes = reverse(n,k);
              t.next = nodes[0];
              t = nodes[1];
              n = nodes[2];
          }
          return res;
          
      }
      
      // 头 尾 下个头
      private ListNode[] reverse(ListNode head,int k){
          ListNode pre = null;
          ListNode cur = head;
          if(!isEnough(head,k)){
               return new ListNode[]{head,null,null};
          }
          while(k-- > 0){
              ListNode next = cur.next;
              cur.next = pre;
              pre = cur;
              cur = next;
          }
          return new ListNode[]{pre,head,cur};
      }
      
      private boolean isEnough(ListNode head,int k){
          while(k-- > 0){
              if(head == null)
                  return false;
              head = head.next;
          }
          return true;
      }
  ```

- 先计算长度再翻转

  ```java
   public ListNode reverseKGroup (ListNode head, int k) {
          // write code here
          int len = getLen(head);
          ListNode dummy = new ListNode(0);
          ListNode ptr = dummy;
          
           ListNode pre ;
           ListNode cur = head;
           ListNode next = head;
           ListNode tail = null;
          for(int i = 0 ; i < len / k ; i++){
              pre = null;
              cur = next;
              tail = cur;
              for(int j = 0 ; j < k ; j++){
                  next = cur.next;
                  cur.next = pre;
                  pre = cur;
                  cur = next;
              }
              ptr.next = pre;
              tail.next = next;
              ptr = tail;
          }
          ptr.next = next;
          return dummy.next;
      }
      
      private int getLen(ListNode head){
          int res = 0;
          while(head != null){
              res++;
              head = head.next;
          }
          return res;
      }
  ```

- 这个好理解 计算长度完成再各自翻转，使用函数，更加清晰

  ```java
    public ListNode reverseKGroup (ListNode head, int k) {
          // write code here
          int len = getLen(head);
          ListNode dummy = new ListNode(0);
          ListNode ptr = dummy;
          
          ListNode newHead = null;
          ListNode newTail = null;
          ListNode next = head;
          for(int i = 0 ; i < len / k ; i++){
              ListNode[] res = reverse(next,k);
              newHead = res[0];
              newTail = res[1];
              next = res[2];
              
              ptr.next = newHead;
              ptr = newTail;
          }
          ptr.next = next;
          return dummy.next;
      }
      
      //头  尾  新的头
      private ListNode[] reverse(ListNode head,int k){
          ListNode pre = null;
          ListNode cur = head;
          ListNode next = null;
          while(k-- > 0){
              next = cur.next;
              cur.next = pre;
              pre = cur;
              cur = next;
          }
          return new ListNode[]{pre,head,next};
      }
      
      
        private int getLen(ListNode head){
          int res = 0;
          while(head != null){
              res++;
              head = head.next;
          }
          return res;
      }
  ```

  



## 10.子数组最大和问题

- 前面求和为负数就清0

  ```java
  public int maxsumofSubarray (int[] arr) {
          // write code here
          int res = Integer.MIN_VALUE;
          int temp = 0;
           for(int i : arr){
              if(temp + i >= 0){
                  temp += i;
              }
               else{
                   temp = 0;
               }
               res = Math.max(res,temp);
           }
          return res;
      }
  ```

  

## 11.二叉树最近祖先

- 真的难

  ```java
  private TreeNode commonAncestor(TreeNode root,int o1,int o2){
          if(root == null || root.val == o1 || root.val == o2){
              return root;
          }
          TreeNode left = commonAncestor(root.left,o1,o2);
          TreeNode right = commonAncestor(root.right,o1,o2);
          if(left == null)
              return right;
          if(right == null)
              return left;
          return root;
      }
  ```

  





## 12.两个链表相加

- stack使用

  ```java
  public ListNode addInList (ListNode head1, ListNode head2) {
          // write code here
          Stack<ListNode> stack1 = new Stack<>();
          Stack<ListNode> stack2 = new Stack<>();
          while(head1 != null){
              stack1.push(head1);
              head1 = head1.next;
          }
          while(head2 != null){
              stack2.push(head2);
              head2 = head2.next;
          }
          
          int carry = 0;
          ListNode temp = null;
          while(!stack1.isEmpty() && !stack2.isEmpty()){
              int val = stack1.pop().val + stack2.pop().val + carry;
              ListNode node = new ListNode(val % 10);
              carry = val / 10;
              node.next = temp;
              temp = node;
          }
          
          while(!stack1.isEmpty()){
                int val = stack1.pop().val + carry;
              ListNode node = new ListNode(val % 10);
              carry = val / 10;
              node.next = temp;
              temp = node;
          }
          
          while(!stack2.isEmpty()){
                int val = stack2.pop().val + carry;
              ListNode node = new ListNode(val % 10);
              carry = val / 10;
              node.next = temp;
              temp = node;
          }
          if(carry == 1){
              ListNode node = new ListNode(1);
              node.next = temp;
              return node;
          }
          else{
              return temp;
          }
          
      }
  ```

- 反转链表

  ```java
  public ListNode addInList (ListNode head1, ListNode head2) {
          // write code here
          ListNode l1 = reverse(head1);
          ListNode l2 = reverse(head2);
          ListNode dummy = new ListNode(-1);
          ListNode cur = dummy;
          int carry = 0;
          while(l1 != null || l2 != null){
              int val = carry;
              if(l1 != null){
                  val += l1.val;
                  l1 = l1.next;
              }
              if(l2 != null){
                  val += l2.val;
                  l2 = l2.next;
              }
              cur.next = new ListNode(val % 10);
              cur = cur.next;
              carry = val / 10;
          }
          if(carry == 1){
              cur.next = new ListNode(1);
              cur = cur.next;
          }
          return reverse(dummy.next);
           
      }
       
      private ListNode reverse(ListNode head){
          ListNode pre = null;
          ListNode cur = head;
          while(cur != null){
              ListNode temp = cur.next;
              cur.next = pre;
              pre = cur;
              cur = temp;
          }
          return pre;
      }
  ```


## 13.判断二叉树是不是完全的

- 空节点之后不能再遇到空节点

  ```java
  private boolean isFull(TreeNode root){
          if(root == null)
              return true;
          Queue<TreeNode> queue = new LinkedList<>();
          queue.offer(root);
      	//是不是遇到空节点了
          boolean existNull = false;
          while(!queue.isEmpty()){
              TreeNode cur = queue.poll();
              //遇到空节点，continue
              if(cur == null){
                  existNull = true;
                  continue;
              }
              //空节点之后遇到了非空的节点
              if(existNull)
                  return false;
              queue.offer(cur.left);
              queue.offer(cur.right);
          }
          return true;
      }
  ```

  



## 14. 删除k个字符使得数剩下的数最小

- 单调队列  从前往后删除

  ```java
   public String removeKdigits(String num, int k) {
          Deque<Character> deque = new LinkedList<>();
          for(int i = 0 ; i < num.length() ; i++){
              char c = num.charAt(i);
              while(!deque.isEmpty() && deque.peekLast() > c && k > 0){
                  deque.pollLast();
                  k--;
              }
              deque.addLast(c);
          }
          for(int i = 0 ; i < k ; i++){
              deque.pollLast();
          }
  
          StringBuilder sb = new StringBuilder();
          boolean first = true;
          while(!deque.isEmpty()){
              char c = deque.pollFirst();
              if(first && c == '0'){
                  continue;
              }
              first = false;
              sb.append(c);
          }
          return sb.length() == 0 ? "0" : sb.toString();
      }
  ```




## 15.最长公共子串

- 动态规划 

- `//dp[i][j]代表 str1[0~i-1]和str2[0~j-1] 的最长公共子串的长度 `

  ```java
  public String LCS (String str1, String str2) {
          // write code here
          int m = str1.length();
          int n = str2.length();
          int[][] dp = new int[m + 1][n + 1];
          int index = 0;
          int maxLen = 0;
          for(int i = 0 ; i < m ; i++){
              for(int j = 0 ; j < n ; j++){
                  if(str1.charAt(i) == str2.charAt(j)){
                      dp[i + 1][j + 1] = dp[i][j] + 1;
                      if(maxLen < dp[i + 1][j + 1]){
                          maxLen = dp[i + 1][j + 1];
                          index = i + 1;
                      }
                  }
              }
          }
          return maxLen == 0 ? "-1" : str1.substring(index - maxLen,index);
      }
  ```





## 16.求平方根

- 二分

  ```java
  public int sqrt (int x) {
          // write code here
          if(x <= 0)
              return 0;
          int left = 1;
          int right = x;
          while(left < right){
              int mid = left + (right - left) / 2;
              if(mid  <= x / mid && (mid + 1) > x / (mid+1)){
                  return mid;
              }
              if(mid < x/ mid){
                  left = mid + 1;
              }
              else{
                  right = mid - 1;
              }
          }
          return left;
      }
  ```





## 17.合并K个排序链表

- 两两合并

  ```java
   public ListNode mergeKLists(ArrayList<ListNode> lists) {
          if(lists == null || lists.size() == 0)
              return null;
          ListNode res = null;
          for(int i = 0 ; i < lists.size() ; i++){
              res = merge(res, lists.get(i));
          }
          return res;
      }
      
      private ListNode merge(ListNode l1,ListNode l2){
          ListNode dummy = new ListNode(0);
          ListNode cur = dummy;
          while(l1 != null && l2 != null){
              if(l1.val <= l2.val){
                  cur.next = l1;
                  l1 = l1.next;
              }
              else{
                  cur.next = l2;
                  l2 = l2.next;
              }
              cur = cur.next;
          }
          if(l1 != null){
              cur.next = l1;
          }
          if(l2 != null){
              cur.next = l2;
          }
          return dummy.next;
      }
  ```

  





## 18.岛屿的数量

- dfs 注意`char[][]` 元素比较使用 `char[x][y] == '1'`引号不能省掉

  ```java
  private boolean[][] visited;
      public int numIslands(char[][] grid) {
   // write code here
          if(grid == null || grid.length == 0)
              return 0;
          if(grid[0].length == 0)
              return 0;
          int row = grid.length;
          int col = grid[0].length;
          visited = new boolean[row][col];
          int res = 0;
          for(int i = 0 ; i < row ; i++){
              for(int j = 0 ; j < col ; j++){
                  // 注意引号！！！不能省
                  if(grid[i][j] == '1' && visited[i][j] == false){
                      res++;
                      dfs(grid,i,j);
                  }
              }
          }
          return res;
      }
      
      private void dfs(char[][] grid,int x,int y){
          int row = grid.length;
          int col = grid[0].length;
         if(x < 0 || x >= row || y < 0 || y >= col || visited[x][y] || grid[x][y] != '1'){
             return;
         }
         visited[x][y] = true;
          dfs(grid,x-1,y);
          dfs(grid,x+1,y);
          dfs(grid,x,y-1);
          dfs(grid,x,y+1);
          
      }
  ```

  ```java
    public int solve (char[][] grid) {
          // write code here
          if(grid == null || grid.length == 0)
              return 0;
          if(grid[0].length == 0)
              return 0;
          int row = grid.length;
          int col = grid[0].length;
          int res = 0;
          for(int i = 0 ; i < row ; i++){
              for(int j = 0 ; j < col ; j++){
                  if(grid[i][j] == '1' ){
                      res++;
                      dfs(grid,i,j);
                  }
              }
          }
          return res;
      }
      
      private void dfs(char[][] grid,int x,int y){
          int row = grid.length;
          int col = grid[0].length;
         if(x < 0 || x >= row || y < 0 || y >= col ||  grid[x][y] != '1'){
             return;
         }
         grid[x][y] = '0';
          dfs(grid,x-1,y);
          dfs(grid,x+1,y);
          dfs(grid,x,y-1);
          dfs(grid,x,y+1);
      }
  ```




## 19.二叉树路径和为某值的路径

- `dfs` 好好体会

  ```java
  private ArrayList<ArrayList<Integer>> res = new ArrayList<>();
      public ArrayList<ArrayList<Integer>> pathSum (TreeNode root, int sum) {
          // write code here
          dfs(root,sum,new ArrayList<Integer>());
          return res;
      }
      
      private void dfs(TreeNode root,int left,ArrayList<Integer> temp){
          if(root == null)
              return;
          left -= root.val;
          temp.add(root.val);
          if(root.left == null && root.right == null){
              if(left == 0)
                  res.add(new ArrayList<Integer>(temp));
          }
          else{
              dfs(root.left,left,temp);
              dfs(root.right,left,temp);
          }
          temp.remove(temp.size() - 1);
      }
  ```

## 20.字符串排列

- 回溯， 使用`visited[]`数组

  ```java
   private ArrayList<String> res = new ArrayList<>();
      public ArrayList<String> Permutation(String str) {
         char[] chars = str.toCharArray();
          Arrays.sort(chars);
          dfs(chars,new boolean[str.length()],new StringBuilder());
          return res;
      }
      
      private void dfs(char[] chars,boolean[] visited,StringBuilder sb){
          if(sb.length() == chars.length){
              if(!res.contains(sb.toString()))
                  res.add(sb.toString());
          }
          for(int i = 0 ; i < chars.length ; i++){
              if(visited[i] == false){
                  sb.append(chars[i]);
                  visited[i] = true;
                  dfs(chars,visited,sb);
                  visited[i] = false;
                  sb.deleteCharAt(sb.length() - 1);
              }
          }
          
      }
  ```

  





## 21.三个数的和为0的组合

- 排序 + 双指针

  ```java
   public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
          ArrayList<ArrayList<Integer>> res = new ArrayList<>();
          Arrays.sort(num);
          for(int i = 0 ; i <= num.length - 3 ; i++){
              int left = i + 1;
              int right = num.length - 1;
              int target = -num[i];
              while(left < right){
                  if(num[left] + num[right] == target){
                      ArrayList<Integer> temp = new ArrayList<>();
                      temp.add(num[i]);
                      temp.add(num[left]);
                      temp.add(num[right]);
                      res.add(temp);
                      while(left  < right && num[left] == num[left + 1]){
                          left++;
                       }
                      while(left < right && num[right] == num[right -1]){
                          right--;
                      }
                      //这句防止死循环
                      left++;
                  }
                  else if(num[left] + num[right] < target){
                      left++;
                  }
                  else{
                      right--;
                  }
              }
              //这里也要去重
              while(i <= num.length - 3 && num[i + 1] == num[i]){
                  i++;
              }
          }
          return res;
      }
  ```


## 21.在转动过的数组找值

- 右边必有序？

  

  ```java
    public int search (int[] A, int target) {
          // write code here
          int left = 0;
          int right = A.length - 1;
          while(left <= right){
              int mid = left + (right - left) / 2;
              if(A[mid] == target)
                  return mid;
              //右边有序
              if(A[mid] < A[right]){
                    if(target > A[mid] && target <= A[right]){
                      left = mid + 1;
                  }
                  else{
                      right = mid - 1;
                  } 
              }
              //左边有序
              else{
                  if(target >= A[left] && target < A[mid]){
                      right = mid - 1;
                  }
                  else{
                      left = mid + 1;
                  } 
              }
          }
          return -1;
      }
  ```

  



## 22.数组中出现次数超过一半的数字

- 摩尔投票 一换一思想

  ```java
    public int MoreThanHalfNum_Solution(int [] array) {
          int candidate = array[0];
          int count = 1;
          for(int i = 1 ; i < array.length ; i++){
              //战场上没人
               if(count == 0){
                  candidate = array[i];
              }
              //同一阵营
              if(array[i] == candidate){
                  count++;
              }
              //不同阵营
              else{
                  count--;
              }
          }
          count = 0;
          for(int i : array){
              if(i == candidate)
                  count++;
          }
          return count > array.length / 2 ? candidate : 0;
      }
  ```

  

## 23.盛雨水问题

- 按列算，求左边右边最高点的较小值

  ```java
     long[] leftMax = new long[arr.length];
          long[] rightMax = new long[arr.length];
          long right = 0;
          long left = 0;
          for(int i =  1 ; i < arr.length ; i++){
              left = Math.max(left , arr[i - 1]);
              leftMax[i] = left;
          }
          for(int i =  arr.length - 2 ; i >= 0 ; i--){
              right = Math.max(right , arr[i + 1]);
              rightMax[i] = right;
          }
          long res = 0;
          for(int i = 0 ; i < arr.length ; i++){
              long min = Math.min(leftMax[i] , rightMax[i]);
              if(min > arr[i])
                  res += (min - arr[i]);
          }
          return res;
      }
  ```


## 24.数组中没有出现的最小正数

- 将每个1-n的数放在0-（n-1）的位置

  ```java
   public int minNumberdisappered (int[] arr) {
          // write code here
          for(int i = 0 ; i < arr.length ; i++){
              //这个地方是while不是if
              while( 1 <= arr[i] && arr[i] <= arr.length && arr[i] != arr[arr[i] - 1]){
                  swap(arr,i,arr[i] - 1);
              }
          }
          for(int i = 0 ; i < arr.length ; i++){
              if(arr[i] != i + 1)
                  return i + 1;
          }
          return arr.length + 1;
      }
      
      private void swap(int[] arr,int l,int r){
          int t = arr[l];
          arr[l] = arr[r];
          arr[r] = t;
      }
  ```



## 25.二叉树是否存在某路径为一值的路径

- dfs

  ```java
   public boolean hasPathSum (TreeNode root, int sum) {
          // write code here
          return dfs(root,sum);
      }
      
      private boolean dfs(TreeNode root,int sum){
          if(root == null)
              return false;
          sum -= root.val;
          if(root.left == null && root.right == null){
              if(sum == 0)
                  return true;
          }
          boolean res = dfs(root.left,sum) || dfs(root.right,sum);
          //sum += root.val;
          return res;
      }
  ```

  





## 26.带重复数字的全排列

- 自己写的最后判断是不是重复

  ```java
   ArrayList<ArrayList<Integer>> res = new ArrayList<>();
      public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
          Arrays.sort(num);
          dfs(num,new boolean[num.length],new ArrayList<>());
          return res;
      }
      
      private void dfs(int[] num,boolean[] visited,ArrayList<Integer> temp){
          if(temp.size() == num.length){
              if(!res.contains(temp))
                  res.add(new ArrayList<>(temp));
              return;
          }
          for(int i = 0 ; i < num.length ; i++){
              if(visited[i]){
                  continue;
              }
              visited[i] = true;
              temp.add(num[i]);
              dfs(num,visited,temp);
              visited[i] = false;
              temp.remove(temp.size() - 1);
          }
      }
  ```

- dfs 中判断

  ```java
   ArrayList<ArrayList<Integer>> res = new ArrayList<>();
      public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
          Arrays.sort(num);
          dfs(num,new boolean[num.length],new ArrayList<>());
          return res;
      }
      
      private void dfs(int[] num,boolean[] visited,ArrayList<Integer> temp){
          if(temp.size() == num.length){
              res.add(new ArrayList<>(temp));
              return;
          }
          for(int i = 0 ; i < num.length ; i++){
              if(visited[i] || ( i > 0 && num[i] == num[i - 1] && visited[i - 1])){
                  continue;
              }
              visited[i] = true;
              temp.add(num[i]);
              dfs(num,visited,temp);
              visited[i] = false;
              temp.remove(temp.size() - 1);
          }
      }
  ```

  



## 27.重排链表

> 将给定的单链表\ L *L*： L_0→L_1→…→L_{n-1}→L_ n*L*0→*L*1→…→*L**n*−1→*L**n*
> 重新排序为：L_0→L_n →L_1→L_{n-1}→L_2→L_{n-2}→…*L*0→*L**n*→*L*1→*L**n*−1→*L*2→*L**n*−2→…
> 要求使用原地算法，不能改变节点内部的值，需要对实际的节点进行交换。
> 例如：
> 对于给定的单链表{10,20,30,40}，将其重新排序为{10,40,20,30}.

- 拆成两个 翻转后面 接上

  ```java
     public void reorderList(ListNode head) {
             ListNode dummy = new ListNode(-1);
             dummy.next = head;
             ListNode fast = dummy;
             ListNode slow = dummy;
             while(fast != null && fast.next != null){
                 slow = slow.next;
                 fast = fast.next.next;
             }
             ListNode mid = slow.next;
             slow.next = null;
             mid = reverse(mid);
             
             ListNode cur1 = head;
             ListNode cur2 = mid;
             while(true){
                 if(cur1 == null || cur2 == null)
                     break;
                 ListNode next1 = cur1.next;
                 ListNode next2 = cur2.next;
                 cur1.next = cur2;
                 cur2.next = next1;
                 cur1 = next1;
                 cur2 = next2;
             }
      }
      
      private ListNode reverse(ListNode head){
          ListNode pre = null;
          ListNode cur = head;
          while(cur != null){
              ListNode next = cur.next;
              cur.next = pre;
              pre = cur;
              cur = next;
          }
          return pre;
      }
  ```

- 先放到list中

  ```java
   public void reorderList(ListNode head) {
          if(head == null)
              return ;
         List<ListNode> list = new ArrayList<>();
          ListNode cur = head;
          while(cur != null){
              list.add(cur);
              cur = cur.next;
          }
          int left = 0;
          int right = list.size() -1 ;
          while(left < right){
              list.get(left).next = list.get(right);
              left++;
              if(left == right){
                  break;
              }
              list.get(right).next = list.get(left);
              right--;
          }
          list.get(left).next = null;
      }
  ```



## 28.最大正方形

> 给定一个由0和1组成的2维矩阵，返回该矩阵中最大的由1组成的正方形的面积

- 动态规划 `Math.min（左上，左，上） + 1`

  ```java
  public int solve (char[][] matrix) {
          // write code here
          if(matrix.length ==0 || matrix[0].length == 0) return 0;
          int row = matrix.length;
          int col = matrix[0].length;
          int[][] dp = new int[row][col];
          for(int i = 0 ; i < col ; i ++){
              dp[0][i] = matrix[0][i] - '0';
          }
          for(int i = 0 ; i < row ; i++){
              dp[i][0] = matrix[i][0] - '0';
          }
          int res = 0;
          for(int i = 1 ; i < row ; i++){
              for(int j = 1 ; j < col ; j++){
                  if(matrix[i][j] == '1'){
                      dp[i][j] = Math.min(dp[i - 1][j],dp[i - 1][j - 1]);
                      dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] ) + 1;
                      res = Math.max(res,dp[i][j]);
                      }
                  }
              }
           return res * res;
          }
  ```





## 29.判断回文链表

> 给定一个链表，请判断该链表是否为回文结构。

- 拆开 翻转后半边

  ```java
   public boolean isPail (ListNode head) {
          // write code here
          ListNode dummy = new ListNode(-1);
          dummy.next = head;
          ListNode slow = dummy;
          ListNode fast = dummy;
          while(fast != null && fast.next != null){
              slow = slow.next;
              fast = fast.next.next;
          }
          ListNode reverse = reverse(slow.next);
          slow.next = null;
           
          while(head != null && reverse != null){
              if(head.val != reverse.val){
                  return false;
              }
              head = head.next;
              reverse = reverse.next;
          }
          return true;
           
           
      }
       
      private ListNode reverse(ListNode head){
          ListNode pre = null;
          ListNode cur = head;
          while(cur != null){
              ListNode next = cur.next;
              cur.next = pre;
              pre = cur;
              cur = next;
          }
          return pre;
           
      }
  ```

  





## 30.最长回文子串

> 对于一个字符串，请设计一个高效算法，计算其中最长回文子串的长度。
>
> 给定字符串**A**以及它的长度**n**，请返回最长回文子串的长度。

- 动态规划

  ```java
  public int getLongestPalindrome(String A, int n) {
          // write code here
          boolean[][] dp = new boolean[n][n];
          int res = 0;
          for(int l = 0 ; l < n ; l++){
              for(int i = 0 ; i + l < n ; i ++){
                  int j = i + l;
                  if(l == 0){
                      dp[i][j] = true;
                  }
                  else if(l == 1){
                      dp[i][j] = A.charAt(i) == A.charAt(j);
                  }
                  else{
                      dp[i][j] = A.charAt(i) == A.charAt(j) && dp[i + 1][j - 1];
                  }
                  
                  if(dp[i][j])
                      res = Math.max(res,l + 1);
              }
          }
          return res;
      }
  ```

  



## 31.解数独

- dfs

  ```java
   public void solveSudoku(char[][] board) {
          dfs(board,0);
      }
      
      private boolean dfs(char[][] board,int sum){
          if(sum == 81)
              return true;
          int x = sum / 9;
          int y = sum % 9;
          //没有数字
          if(board[x][y] == '.'){
              for(char i = '1' ; i <= '9' ; i++ ){
                  if(isValid(board,x,y,i)){
                      board[x][y] = i;
                      if(dfs(board,sum + 1))
                          return true;
                      else{
                           board[x][y] = '.';
                      }
                  }
              }
          }
          //有数字
          else{
              if(dfs(board,sum+1))
                  return true;
              return false;
          }
          return false;
      }
      
      
      private boolean isValid(char[][] board,int x,int y,char c){
          int row = x / 3;
          int col = y / 3;
          row *= 3;
          col *= 3;
          for(int i = row ; i < row + 3 ; i++){
              for(int j = col ; j < col + 3 ;j++){
                  if(board[i][j] == c)
                      return false;
              }
          }
          
          for(int i = 0 ; i < 9 ; i++){
              if(board[x][i] == c)
                  return false;
          }
          
          for(int i = 0 ; i < 9 ; i++){
              if(board[i][y] == c){
                  return false;
              }
          }
          
          return true;
      }
  ```

  